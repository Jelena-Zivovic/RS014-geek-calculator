%{

#include <iostream>
#include <cstdlib>
#include <string>
#include <cmath>
#include <vector>
#include "MatrixHelper.hpp"


bool indicator_calculating_value=1;

extern int yylex();

void yyerror(MatrixH *return_value, std::string s);

%}

%union {
    MatrixH* m;
    double value;
    char variable;
}

%parse-param  {MatrixH* return_value}

%left '+' '-'
%left '*' '/'
%left INV DET NORM TRANS
%left UMINUS
%left '^' 
%left '!'


%type <m> E
%token <value> NUMBER
%token <variable> A;
%token <variable> B;
%start pocetak

%%
pocetak
    : E {
       *return_value = *$1;
      //*return_value = 0;
        
    };

E   
    : E '+' E {
        if(indicator_calculating_value){
             $$ = *$1 + *$3;
             if($$ == nullptr){
                 return 0;
             }
             delete $1;
             delete $3;
        }
    } 
    | E '*' E {
        if(indicator_calculating_value){
             $$ = *$1 * (*$3);
             if($$ == nullptr){
                 return 0;
             }
             delete $1;
             delete $3;
        }
    }
    | E '-' E {
        if(indicator_calculating_value){
             $$ = *$1 - *$3;
             delete $1;
             delete $3;
        }
    }
    | E '*' NUMBER {
        if(indicator_calculating_value){
            $$ = *$1 * $3;
            delete $1;
        }
    }
    | NUMBER '*' E {
        if(indicator_calculating_value){
            $$ = *$3 * $1;
            delete $3;
        }
    }

    | INV '(' E ')' {
       if(indicator_calculating_value){
             $$ = $3->inv();
             delete $3;
       }
    }
    | NORM '(' E ')' {
       if(indicator_calculating_value){
             $$ = $3->normalized();
             delete $3;
        }
    }
    | TRANS '(' E ')' {
        if(indicator_calculating_value){
             $$ = $3->transpose();
             delete $3;
        }
    }
    | DET '(' E ')'{
        if(indicator_calculating_value){
            Eigen::MatrixXd mat;
            mat.resize(1,1);
            double d = $3->det();
            mat(0,0) = d;

             $$ = new MatrixH(mat);
        }
    }

    | E '^' NUMBER {
        if(indicator_calculating_value){
             $$ = $1->pow($3);
             delete $1;
        }
    }
    | '-' E %prec UMINUS {
        if(indicator_calculating_value){
            $$ = -(*$2);
            delete $2;
        }
    } 
    | '(' E ')' {
       if(indicator_calculating_value){
           $$ = $2;

       }
    }
    | A {
           Eigen::MatrixXd mat;
           mat.resize(2,2);
           mat(0,0) = 1;
           mat(0,1) = 2;
           mat(1,0) = 3;
           mat(1,1) = 3;
           std::cout << mat << std::endl;
           $$ = new MatrixH(mat);

    }
    | B {
           Eigen::MatrixXd mat;
           mat.resize(2,2);
           mat(0,0) = 1;
           mat(0,1) = 1;
           mat(1,0) = 1;
           mat(1,1) = 3;
           std::cout << mat << std::endl;
           $$ =  new MatrixH(mat);
    }
 
    ;


%%

void yyerror(MatrixH *return_value, std::string s)
{
   std::cout << "no no " << std::endl;
   
}
int main(){
    MatrixH v;
    if(yyparse(&v) != 0){
        std::cout << "previse tokena na ulazu" << std::endl;
        exit(EXIT_FAILURE);
    }
    
    std::cout << v << std::endl;
    std::cout<<"Sve ok"<<std::endl;

    
    exit(EXIT_SUCCESS);
}



